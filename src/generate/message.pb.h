// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_INCLUDED_message_2eproto
#define PROTOBUF_INCLUDED_message_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_message_2eproto 

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_message_2eproto
namespace im {
namespace tox {
namespace proto {
class OfflineMessage;
class OfflineMessageDefaultTypeInternal;
extern OfflineMessageDefaultTypeInternal _OfflineMessage_default_instance_;
class OfflineMessageDelReq;
class OfflineMessageDelReqDefaultTypeInternal;
extern OfflineMessageDelReqDefaultTypeInternal _OfflineMessageDelReq_default_instance_;
class OfflineMessagePullReq;
class OfflineMessagePullReqDefaultTypeInternal;
extern OfflineMessagePullReqDefaultTypeInternal _OfflineMessagePullReq_default_instance_;
class OfflineMessagePullRes;
class OfflineMessagePullResDefaultTypeInternal;
extern OfflineMessagePullResDefaultTypeInternal _OfflineMessagePullRes_default_instance_;
class OfflineMessageReadNotice;
class OfflineMessageReadNoticeDefaultTypeInternal;
extern OfflineMessageReadNoticeDefaultTypeInternal _OfflineMessageReadNotice_default_instance_;
class OfflineMessageReq;
class OfflineMessageReqDefaultTypeInternal;
extern OfflineMessageReqDefaultTypeInternal _OfflineMessageReq_default_instance_;
class OfflineMessageRes;
class OfflineMessageResDefaultTypeInternal;
extern OfflineMessageResDefaultTypeInternal _OfflineMessageRes_default_instance_;
class QueryFriendReq;
class QueryFriendReqDefaultTypeInternal;
extern QueryFriendReqDefaultTypeInternal _QueryFriendReq_default_instance_;
class QueryFriendRes;
class QueryFriendResDefaultTypeInternal;
extern QueryFriendResDefaultTypeInternal _QueryFriendRes_default_instance_;
}  // namespace proto
}  // namespace tox
}  // namespace im
namespace google {
namespace protobuf {
template<> ::im::tox::proto::OfflineMessage* Arena::CreateMaybeMessage<::im::tox::proto::OfflineMessage>(Arena*);
template<> ::im::tox::proto::OfflineMessageDelReq* Arena::CreateMaybeMessage<::im::tox::proto::OfflineMessageDelReq>(Arena*);
template<> ::im::tox::proto::OfflineMessagePullReq* Arena::CreateMaybeMessage<::im::tox::proto::OfflineMessagePullReq>(Arena*);
template<> ::im::tox::proto::OfflineMessagePullRes* Arena::CreateMaybeMessage<::im::tox::proto::OfflineMessagePullRes>(Arena*);
template<> ::im::tox::proto::OfflineMessageReadNotice* Arena::CreateMaybeMessage<::im::tox::proto::OfflineMessageReadNotice>(Arena*);
template<> ::im::tox::proto::OfflineMessageReq* Arena::CreateMaybeMessage<::im::tox::proto::OfflineMessageReq>(Arena*);
template<> ::im::tox::proto::OfflineMessageRes* Arena::CreateMaybeMessage<::im::tox::proto::OfflineMessageRes>(Arena*);
template<> ::im::tox::proto::QueryFriendReq* Arena::CreateMaybeMessage<::im::tox::proto::QueryFriendReq>(Arena*);
template<> ::im::tox::proto::QueryFriendRes* Arena::CreateMaybeMessage<::im::tox::proto::QueryFriendRes>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace im {
namespace tox {
namespace proto {

// ===================================================================

class QueryFriendReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im.tox.proto.QueryFriendReq) */ {
 public:
  QueryFriendReq();
  virtual ~QueryFriendReq();

  QueryFriendReq(const QueryFriendReq& from);

  inline QueryFriendReq& operator=(const QueryFriendReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryFriendReq(QueryFriendReq&& from) noexcept
    : QueryFriendReq() {
    *this = ::std::move(from);
  }

  inline QueryFriendReq& operator=(QueryFriendReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryFriendReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryFriendReq* internal_default_instance() {
    return reinterpret_cast<const QueryFriendReq*>(
               &_QueryFriendReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(QueryFriendReq* other);
  friend void swap(QueryFriendReq& a, QueryFriendReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryFriendReq* New() const final {
    return CreateMaybeMessage<QueryFriendReq>(NULL);
  }

  QueryFriendReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryFriendReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const QueryFriendReq& from);
  void MergeFrom(const QueryFriendReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryFriendReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes pk = 1;
  void clear_pk();
  static const int kPkFieldNumber = 1;
  const ::std::string& pk() const;
  void set_pk(const ::std::string& value);
  #if LANG_CXX11
  void set_pk(::std::string&& value);
  #endif
  void set_pk(const char* value);
  void set_pk(const void* value, size_t size);
  ::std::string* mutable_pk();
  ::std::string* release_pk();
  void set_allocated_pk(::std::string* pk);

  // @@protoc_insertion_point(class_scope:im.tox.proto.QueryFriendReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pk_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryFriendRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im.tox.proto.QueryFriendRes) */ {
 public:
  QueryFriendRes();
  virtual ~QueryFriendRes();

  QueryFriendRes(const QueryFriendRes& from);

  inline QueryFriendRes& operator=(const QueryFriendRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryFriendRes(QueryFriendRes&& from) noexcept
    : QueryFriendRes() {
    *this = ::std::move(from);
  }

  inline QueryFriendRes& operator=(QueryFriendRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryFriendRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryFriendRes* internal_default_instance() {
    return reinterpret_cast<const QueryFriendRes*>(
               &_QueryFriendRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(QueryFriendRes* other);
  friend void swap(QueryFriendRes& a, QueryFriendRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryFriendRes* New() const final {
    return CreateMaybeMessage<QueryFriendRes>(NULL);
  }

  QueryFriendRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryFriendRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const QueryFriendRes& from);
  void MergeFrom(const QueryFriendRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryFriendRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes pk = 2;
  void clear_pk();
  static const int kPkFieldNumber = 2;
  const ::std::string& pk() const;
  void set_pk(const ::std::string& value);
  #if LANG_CXX11
  void set_pk(::std::string&& value);
  #endif
  void set_pk(const char* value);
  void set_pk(const void* value, size_t size);
  ::std::string* mutable_pk();
  ::std::string* release_pk();
  void set_allocated_pk(::std::string* pk);

  // uint32 exist = 1;
  void clear_exist();
  static const int kExistFieldNumber = 1;
  ::google::protobuf::uint32 exist() const;
  void set_exist(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:im.tox.proto.QueryFriendRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pk_;
  ::google::protobuf::uint32 exist_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OfflineMessageReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im.tox.proto.OfflineMessageReq) */ {
 public:
  OfflineMessageReq();
  virtual ~OfflineMessageReq();

  OfflineMessageReq(const OfflineMessageReq& from);

  inline OfflineMessageReq& operator=(const OfflineMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OfflineMessageReq(OfflineMessageReq&& from) noexcept
    : OfflineMessageReq() {
    *this = ::std::move(from);
  }

  inline OfflineMessageReq& operator=(OfflineMessageReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineMessageReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OfflineMessageReq* internal_default_instance() {
    return reinterpret_cast<const OfflineMessageReq*>(
               &_OfflineMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(OfflineMessageReq* other);
  friend void swap(OfflineMessageReq& a, OfflineMessageReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfflineMessageReq* New() const final {
    return CreateMaybeMessage<OfflineMessageReq>(NULL);
  }

  OfflineMessageReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OfflineMessageReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OfflineMessageReq& from);
  void MergeFrom(const OfflineMessageReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfflineMessageReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes to_pk = 2;
  void clear_to_pk();
  static const int kToPkFieldNumber = 2;
  const ::std::string& to_pk() const;
  void set_to_pk(const ::std::string& value);
  #if LANG_CXX11
  void set_to_pk(::std::string&& value);
  #endif
  void set_to_pk(const char* value);
  void set_to_pk(const void* value, size_t size);
  ::std::string* mutable_to_pk();
  ::std::string* release_to_pk();
  void set_allocated_to_pk(::std::string* to_pk);

  // bytes crypto_message = 3;
  void clear_crypto_message();
  static const int kCryptoMessageFieldNumber = 3;
  const ::std::string& crypto_message() const;
  void set_crypto_message(const ::std::string& value);
  #if LANG_CXX11
  void set_crypto_message(::std::string&& value);
  #endif
  void set_crypto_message(const char* value);
  void set_crypto_message(const void* value, size_t size);
  ::std::string* mutable_crypto_message();
  ::std::string* release_crypto_message();
  void set_allocated_crypto_message(::std::string* crypto_message);

  // int64 local_msg_id = 1;
  void clear_local_msg_id();
  static const int kLocalMsgIdFieldNumber = 1;
  ::google::protobuf::int64 local_msg_id() const;
  void set_local_msg_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:im.tox.proto.OfflineMessageReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr to_pk_;
  ::google::protobuf::internal::ArenaStringPtr crypto_message_;
  ::google::protobuf::int64 local_msg_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OfflineMessageRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im.tox.proto.OfflineMessageRes) */ {
 public:
  OfflineMessageRes();
  virtual ~OfflineMessageRes();

  OfflineMessageRes(const OfflineMessageRes& from);

  inline OfflineMessageRes& operator=(const OfflineMessageRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OfflineMessageRes(OfflineMessageRes&& from) noexcept
    : OfflineMessageRes() {
    *this = ::std::move(from);
  }

  inline OfflineMessageRes& operator=(OfflineMessageRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineMessageRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OfflineMessageRes* internal_default_instance() {
    return reinterpret_cast<const OfflineMessageRes*>(
               &_OfflineMessageRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(OfflineMessageRes* other);
  friend void swap(OfflineMessageRes& a, OfflineMessageRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfflineMessageRes* New() const final {
    return CreateMaybeMessage<OfflineMessageRes>(NULL);
  }

  OfflineMessageRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OfflineMessageRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OfflineMessageRes& from);
  void MergeFrom(const OfflineMessageRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfflineMessageRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 local_msg_id = 1;
  void clear_local_msg_id();
  static const int kLocalMsgIdFieldNumber = 1;
  ::google::protobuf::int64 local_msg_id() const;
  void set_local_msg_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:im.tox.proto.OfflineMessageRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 local_msg_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OfflineMessageReadNotice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im.tox.proto.OfflineMessageReadNotice) */ {
 public:
  OfflineMessageReadNotice();
  virtual ~OfflineMessageReadNotice();

  OfflineMessageReadNotice(const OfflineMessageReadNotice& from);

  inline OfflineMessageReadNotice& operator=(const OfflineMessageReadNotice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OfflineMessageReadNotice(OfflineMessageReadNotice&& from) noexcept
    : OfflineMessageReadNotice() {
    *this = ::std::move(from);
  }

  inline OfflineMessageReadNotice& operator=(OfflineMessageReadNotice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineMessageReadNotice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OfflineMessageReadNotice* internal_default_instance() {
    return reinterpret_cast<const OfflineMessageReadNotice*>(
               &_OfflineMessageReadNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(OfflineMessageReadNotice* other);
  friend void swap(OfflineMessageReadNotice& a, OfflineMessageReadNotice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfflineMessageReadNotice* New() const final {
    return CreateMaybeMessage<OfflineMessageReadNotice>(NULL);
  }

  OfflineMessageReadNotice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OfflineMessageReadNotice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OfflineMessageReadNotice& from);
  void MergeFrom(const OfflineMessageReadNotice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfflineMessageReadNotice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 latest_msg_id = 1;
  void clear_latest_msg_id();
  static const int kLatestMsgIdFieldNumber = 1;
  ::google::protobuf::uint64 latest_msg_id() const;
  void set_latest_msg_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:im.tox.proto.OfflineMessageReadNotice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 latest_msg_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OfflineMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im.tox.proto.OfflineMessage) */ {
 public:
  OfflineMessage();
  virtual ~OfflineMessage();

  OfflineMessage(const OfflineMessage& from);

  inline OfflineMessage& operator=(const OfflineMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OfflineMessage(OfflineMessage&& from) noexcept
    : OfflineMessage() {
    *this = ::std::move(from);
  }

  inline OfflineMessage& operator=(OfflineMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OfflineMessage* internal_default_instance() {
    return reinterpret_cast<const OfflineMessage*>(
               &_OfflineMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(OfflineMessage* other);
  friend void swap(OfflineMessage& a, OfflineMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfflineMessage* New() const final {
    return CreateMaybeMessage<OfflineMessage>(NULL);
  }

  OfflineMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OfflineMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OfflineMessage& from);
  void MergeFrom(const OfflineMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfflineMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes fr_pk = 3;
  void clear_fr_pk();
  static const int kFrPkFieldNumber = 3;
  const ::std::string& fr_pk() const;
  void set_fr_pk(const ::std::string& value);
  #if LANG_CXX11
  void set_fr_pk(::std::string&& value);
  #endif
  void set_fr_pk(const char* value);
  void set_fr_pk(const void* value, size_t size);
  ::std::string* mutable_fr_pk();
  ::std::string* release_fr_pk();
  void set_allocated_fr_pk(::std::string* fr_pk);

  // bytes to_pk = 4;
  void clear_to_pk();
  static const int kToPkFieldNumber = 4;
  const ::std::string& to_pk() const;
  void set_to_pk(const ::std::string& value);
  #if LANG_CXX11
  void set_to_pk(::std::string&& value);
  #endif
  void set_to_pk(const char* value);
  void set_to_pk(const void* value, size_t size);
  ::std::string* mutable_to_pk();
  ::std::string* release_to_pk();
  void set_allocated_to_pk(::std::string* to_pk);

  // bytes content = 5;
  void clear_content();
  static const int kContentFieldNumber = 5;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // int64 local_msg_id = 1;
  void clear_local_msg_id();
  static const int kLocalMsgIdFieldNumber = 1;
  ::google::protobuf::int64 local_msg_id() const;
  void set_local_msg_id(::google::protobuf::int64 value);

  // uint64 msg_id = 2;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  ::google::protobuf::uint64 msg_id() const;
  void set_msg_id(::google::protobuf::uint64 value);

  // uint64 create_time = 6;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 6;
  ::google::protobuf::uint64 create_time() const;
  void set_create_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:im.tox.proto.OfflineMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr fr_pk_;
  ::google::protobuf::internal::ArenaStringPtr to_pk_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::int64 local_msg_id_;
  ::google::protobuf::uint64 msg_id_;
  ::google::protobuf::uint64 create_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OfflineMessagePullReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im.tox.proto.OfflineMessagePullReq) */ {
 public:
  OfflineMessagePullReq();
  virtual ~OfflineMessagePullReq();

  OfflineMessagePullReq(const OfflineMessagePullReq& from);

  inline OfflineMessagePullReq& operator=(const OfflineMessagePullReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OfflineMessagePullReq(OfflineMessagePullReq&& from) noexcept
    : OfflineMessagePullReq() {
    *this = ::std::move(from);
  }

  inline OfflineMessagePullReq& operator=(OfflineMessagePullReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineMessagePullReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OfflineMessagePullReq* internal_default_instance() {
    return reinterpret_cast<const OfflineMessagePullReq*>(
               &_OfflineMessagePullReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(OfflineMessagePullReq* other);
  friend void swap(OfflineMessagePullReq& a, OfflineMessagePullReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfflineMessagePullReq* New() const final {
    return CreateMaybeMessage<OfflineMessagePullReq>(NULL);
  }

  OfflineMessagePullReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OfflineMessagePullReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OfflineMessagePullReq& from);
  void MergeFrom(const OfflineMessagePullReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfflineMessagePullReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:im.tox.proto.OfflineMessagePullReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OfflineMessagePullRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im.tox.proto.OfflineMessagePullRes) */ {
 public:
  OfflineMessagePullRes();
  virtual ~OfflineMessagePullRes();

  OfflineMessagePullRes(const OfflineMessagePullRes& from);

  inline OfflineMessagePullRes& operator=(const OfflineMessagePullRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OfflineMessagePullRes(OfflineMessagePullRes&& from) noexcept
    : OfflineMessagePullRes() {
    *this = ::std::move(from);
  }

  inline OfflineMessagePullRes& operator=(OfflineMessagePullRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineMessagePullRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OfflineMessagePullRes* internal_default_instance() {
    return reinterpret_cast<const OfflineMessagePullRes*>(
               &_OfflineMessagePullRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(OfflineMessagePullRes* other);
  friend void swap(OfflineMessagePullRes& a, OfflineMessagePullRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfflineMessagePullRes* New() const final {
    return CreateMaybeMessage<OfflineMessagePullRes>(NULL);
  }

  OfflineMessagePullRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OfflineMessagePullRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OfflineMessagePullRes& from);
  void MergeFrom(const OfflineMessagePullRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfflineMessagePullRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .im.tox.proto.OfflineMessage msg = 1;
  int msg_size() const;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  ::im::tox::proto::OfflineMessage* mutable_msg(int index);
  ::google::protobuf::RepeatedPtrField< ::im::tox::proto::OfflineMessage >*
      mutable_msg();
  const ::im::tox::proto::OfflineMessage& msg(int index) const;
  ::im::tox::proto::OfflineMessage* add_msg();
  const ::google::protobuf::RepeatedPtrField< ::im::tox::proto::OfflineMessage >&
      msg() const;

  // uint32 left_count = 2;
  void clear_left_count();
  static const int kLeftCountFieldNumber = 2;
  ::google::protobuf::uint32 left_count() const;
  void set_left_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:im.tox.proto.OfflineMessagePullRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::im::tox::proto::OfflineMessage > msg_;
  ::google::protobuf::uint32 left_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OfflineMessageDelReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im.tox.proto.OfflineMessageDelReq) */ {
 public:
  OfflineMessageDelReq();
  virtual ~OfflineMessageDelReq();

  OfflineMessageDelReq(const OfflineMessageDelReq& from);

  inline OfflineMessageDelReq& operator=(const OfflineMessageDelReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OfflineMessageDelReq(OfflineMessageDelReq&& from) noexcept
    : OfflineMessageDelReq() {
    *this = ::std::move(from);
  }

  inline OfflineMessageDelReq& operator=(OfflineMessageDelReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineMessageDelReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OfflineMessageDelReq* internal_default_instance() {
    return reinterpret_cast<const OfflineMessageDelReq*>(
               &_OfflineMessageDelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(OfflineMessageDelReq* other);
  friend void swap(OfflineMessageDelReq& a, OfflineMessageDelReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfflineMessageDelReq* New() const final {
    return CreateMaybeMessage<OfflineMessageDelReq>(NULL);
  }

  OfflineMessageDelReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OfflineMessageDelReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OfflineMessageDelReq& from);
  void MergeFrom(const OfflineMessageDelReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfflineMessageDelReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 last_msg_id = 2;
  void clear_last_msg_id();
  static const int kLastMsgIdFieldNumber = 2;
  ::google::protobuf::uint64 last_msg_id() const;
  void set_last_msg_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:im.tox.proto.OfflineMessageDelReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 last_msg_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// QueryFriendReq

// bytes pk = 1;
inline void QueryFriendReq::clear_pk() {
  pk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& QueryFriendReq::pk() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.QueryFriendReq.pk)
  return pk_.GetNoArena();
}
inline void QueryFriendReq::set_pk(const ::std::string& value) {
  
  pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.tox.proto.QueryFriendReq.pk)
}
#if LANG_CXX11
inline void QueryFriendReq::set_pk(::std::string&& value) {
  
  pk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.tox.proto.QueryFriendReq.pk)
}
#endif
inline void QueryFriendReq::set_pk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.tox.proto.QueryFriendReq.pk)
}
inline void QueryFriendReq::set_pk(const void* value, size_t size) {
  
  pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.tox.proto.QueryFriendReq.pk)
}
inline ::std::string* QueryFriendReq::mutable_pk() {
  
  // @@protoc_insertion_point(field_mutable:im.tox.proto.QueryFriendReq.pk)
  return pk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryFriendReq::release_pk() {
  // @@protoc_insertion_point(field_release:im.tox.proto.QueryFriendReq.pk)
  
  return pk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryFriendReq::set_allocated_pk(::std::string* pk) {
  if (pk != NULL) {
    
  } else {
    
  }
  pk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pk);
  // @@protoc_insertion_point(field_set_allocated:im.tox.proto.QueryFriendReq.pk)
}

// -------------------------------------------------------------------

// QueryFriendRes

// uint32 exist = 1;
inline void QueryFriendRes::clear_exist() {
  exist_ = 0u;
}
inline ::google::protobuf::uint32 QueryFriendRes::exist() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.QueryFriendRes.exist)
  return exist_;
}
inline void QueryFriendRes::set_exist(::google::protobuf::uint32 value) {
  
  exist_ = value;
  // @@protoc_insertion_point(field_set:im.tox.proto.QueryFriendRes.exist)
}

// bytes pk = 2;
inline void QueryFriendRes::clear_pk() {
  pk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& QueryFriendRes::pk() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.QueryFriendRes.pk)
  return pk_.GetNoArena();
}
inline void QueryFriendRes::set_pk(const ::std::string& value) {
  
  pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.tox.proto.QueryFriendRes.pk)
}
#if LANG_CXX11
inline void QueryFriendRes::set_pk(::std::string&& value) {
  
  pk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.tox.proto.QueryFriendRes.pk)
}
#endif
inline void QueryFriendRes::set_pk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.tox.proto.QueryFriendRes.pk)
}
inline void QueryFriendRes::set_pk(const void* value, size_t size) {
  
  pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.tox.proto.QueryFriendRes.pk)
}
inline ::std::string* QueryFriendRes::mutable_pk() {
  
  // @@protoc_insertion_point(field_mutable:im.tox.proto.QueryFriendRes.pk)
  return pk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryFriendRes::release_pk() {
  // @@protoc_insertion_point(field_release:im.tox.proto.QueryFriendRes.pk)
  
  return pk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryFriendRes::set_allocated_pk(::std::string* pk) {
  if (pk != NULL) {
    
  } else {
    
  }
  pk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pk);
  // @@protoc_insertion_point(field_set_allocated:im.tox.proto.QueryFriendRes.pk)
}

// -------------------------------------------------------------------

// OfflineMessageReq

// int64 local_msg_id = 1;
inline void OfflineMessageReq::clear_local_msg_id() {
  local_msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OfflineMessageReq::local_msg_id() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessageReq.local_msg_id)
  return local_msg_id_;
}
inline void OfflineMessageReq::set_local_msg_id(::google::protobuf::int64 value) {
  
  local_msg_id_ = value;
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessageReq.local_msg_id)
}

// bytes to_pk = 2;
inline void OfflineMessageReq::clear_to_pk() {
  to_pk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OfflineMessageReq::to_pk() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessageReq.to_pk)
  return to_pk_.GetNoArena();
}
inline void OfflineMessageReq::set_to_pk(const ::std::string& value) {
  
  to_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessageReq.to_pk)
}
#if LANG_CXX11
inline void OfflineMessageReq::set_to_pk(::std::string&& value) {
  
  to_pk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.tox.proto.OfflineMessageReq.to_pk)
}
#endif
inline void OfflineMessageReq::set_to_pk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.tox.proto.OfflineMessageReq.to_pk)
}
inline void OfflineMessageReq::set_to_pk(const void* value, size_t size) {
  
  to_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.tox.proto.OfflineMessageReq.to_pk)
}
inline ::std::string* OfflineMessageReq::mutable_to_pk() {
  
  // @@protoc_insertion_point(field_mutable:im.tox.proto.OfflineMessageReq.to_pk)
  return to_pk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OfflineMessageReq::release_to_pk() {
  // @@protoc_insertion_point(field_release:im.tox.proto.OfflineMessageReq.to_pk)
  
  return to_pk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OfflineMessageReq::set_allocated_to_pk(::std::string* to_pk) {
  if (to_pk != NULL) {
    
  } else {
    
  }
  to_pk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_pk);
  // @@protoc_insertion_point(field_set_allocated:im.tox.proto.OfflineMessageReq.to_pk)
}

// bytes crypto_message = 3;
inline void OfflineMessageReq::clear_crypto_message() {
  crypto_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OfflineMessageReq::crypto_message() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessageReq.crypto_message)
  return crypto_message_.GetNoArena();
}
inline void OfflineMessageReq::set_crypto_message(const ::std::string& value) {
  
  crypto_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessageReq.crypto_message)
}
#if LANG_CXX11
inline void OfflineMessageReq::set_crypto_message(::std::string&& value) {
  
  crypto_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.tox.proto.OfflineMessageReq.crypto_message)
}
#endif
inline void OfflineMessageReq::set_crypto_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  crypto_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.tox.proto.OfflineMessageReq.crypto_message)
}
inline void OfflineMessageReq::set_crypto_message(const void* value, size_t size) {
  
  crypto_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.tox.proto.OfflineMessageReq.crypto_message)
}
inline ::std::string* OfflineMessageReq::mutable_crypto_message() {
  
  // @@protoc_insertion_point(field_mutable:im.tox.proto.OfflineMessageReq.crypto_message)
  return crypto_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OfflineMessageReq::release_crypto_message() {
  // @@protoc_insertion_point(field_release:im.tox.proto.OfflineMessageReq.crypto_message)
  
  return crypto_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OfflineMessageReq::set_allocated_crypto_message(::std::string* crypto_message) {
  if (crypto_message != NULL) {
    
  } else {
    
  }
  crypto_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), crypto_message);
  // @@protoc_insertion_point(field_set_allocated:im.tox.proto.OfflineMessageReq.crypto_message)
}

// -------------------------------------------------------------------

// OfflineMessageRes

// int64 local_msg_id = 1;
inline void OfflineMessageRes::clear_local_msg_id() {
  local_msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OfflineMessageRes::local_msg_id() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessageRes.local_msg_id)
  return local_msg_id_;
}
inline void OfflineMessageRes::set_local_msg_id(::google::protobuf::int64 value) {
  
  local_msg_id_ = value;
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessageRes.local_msg_id)
}

// -------------------------------------------------------------------

// OfflineMessageReadNotice

// uint64 latest_msg_id = 1;
inline void OfflineMessageReadNotice::clear_latest_msg_id() {
  latest_msg_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OfflineMessageReadNotice::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessageReadNotice.latest_msg_id)
  return latest_msg_id_;
}
inline void OfflineMessageReadNotice::set_latest_msg_id(::google::protobuf::uint64 value) {
  
  latest_msg_id_ = value;
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessageReadNotice.latest_msg_id)
}

// -------------------------------------------------------------------

// OfflineMessage

// int64 local_msg_id = 1;
inline void OfflineMessage::clear_local_msg_id() {
  local_msg_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OfflineMessage::local_msg_id() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessage.local_msg_id)
  return local_msg_id_;
}
inline void OfflineMessage::set_local_msg_id(::google::protobuf::int64 value) {
  
  local_msg_id_ = value;
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessage.local_msg_id)
}

// uint64 msg_id = 2;
inline void OfflineMessage::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OfflineMessage::msg_id() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessage.msg_id)
  return msg_id_;
}
inline void OfflineMessage::set_msg_id(::google::protobuf::uint64 value) {
  
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessage.msg_id)
}

// bytes fr_pk = 3;
inline void OfflineMessage::clear_fr_pk() {
  fr_pk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OfflineMessage::fr_pk() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessage.fr_pk)
  return fr_pk_.GetNoArena();
}
inline void OfflineMessage::set_fr_pk(const ::std::string& value) {
  
  fr_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessage.fr_pk)
}
#if LANG_CXX11
inline void OfflineMessage::set_fr_pk(::std::string&& value) {
  
  fr_pk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.tox.proto.OfflineMessage.fr_pk)
}
#endif
inline void OfflineMessage::set_fr_pk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fr_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.tox.proto.OfflineMessage.fr_pk)
}
inline void OfflineMessage::set_fr_pk(const void* value, size_t size) {
  
  fr_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.tox.proto.OfflineMessage.fr_pk)
}
inline ::std::string* OfflineMessage::mutable_fr_pk() {
  
  // @@protoc_insertion_point(field_mutable:im.tox.proto.OfflineMessage.fr_pk)
  return fr_pk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OfflineMessage::release_fr_pk() {
  // @@protoc_insertion_point(field_release:im.tox.proto.OfflineMessage.fr_pk)
  
  return fr_pk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OfflineMessage::set_allocated_fr_pk(::std::string* fr_pk) {
  if (fr_pk != NULL) {
    
  } else {
    
  }
  fr_pk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fr_pk);
  // @@protoc_insertion_point(field_set_allocated:im.tox.proto.OfflineMessage.fr_pk)
}

// bytes to_pk = 4;
inline void OfflineMessage::clear_to_pk() {
  to_pk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OfflineMessage::to_pk() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessage.to_pk)
  return to_pk_.GetNoArena();
}
inline void OfflineMessage::set_to_pk(const ::std::string& value) {
  
  to_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessage.to_pk)
}
#if LANG_CXX11
inline void OfflineMessage::set_to_pk(::std::string&& value) {
  
  to_pk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.tox.proto.OfflineMessage.to_pk)
}
#endif
inline void OfflineMessage::set_to_pk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.tox.proto.OfflineMessage.to_pk)
}
inline void OfflineMessage::set_to_pk(const void* value, size_t size) {
  
  to_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.tox.proto.OfflineMessage.to_pk)
}
inline ::std::string* OfflineMessage::mutable_to_pk() {
  
  // @@protoc_insertion_point(field_mutable:im.tox.proto.OfflineMessage.to_pk)
  return to_pk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OfflineMessage::release_to_pk() {
  // @@protoc_insertion_point(field_release:im.tox.proto.OfflineMessage.to_pk)
  
  return to_pk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OfflineMessage::set_allocated_to_pk(::std::string* to_pk) {
  if (to_pk != NULL) {
    
  } else {
    
  }
  to_pk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_pk);
  // @@protoc_insertion_point(field_set_allocated:im.tox.proto.OfflineMessage.to_pk)
}

// bytes content = 5;
inline void OfflineMessage::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OfflineMessage::content() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessage.content)
  return content_.GetNoArena();
}
inline void OfflineMessage::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessage.content)
}
#if LANG_CXX11
inline void OfflineMessage::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im.tox.proto.OfflineMessage.content)
}
#endif
inline void OfflineMessage::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im.tox.proto.OfflineMessage.content)
}
inline void OfflineMessage::set_content(const void* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im.tox.proto.OfflineMessage.content)
}
inline ::std::string* OfflineMessage::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:im.tox.proto.OfflineMessage.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OfflineMessage::release_content() {
  // @@protoc_insertion_point(field_release:im.tox.proto.OfflineMessage.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OfflineMessage::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:im.tox.proto.OfflineMessage.content)
}

// uint64 create_time = 6;
inline void OfflineMessage::clear_create_time() {
  create_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OfflineMessage::create_time() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessage.create_time)
  return create_time_;
}
inline void OfflineMessage::set_create_time(::google::protobuf::uint64 value) {
  
  create_time_ = value;
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessage.create_time)
}

// -------------------------------------------------------------------

// OfflineMessagePullReq

// -------------------------------------------------------------------

// OfflineMessagePullRes

// repeated .im.tox.proto.OfflineMessage msg = 1;
inline int OfflineMessagePullRes::msg_size() const {
  return msg_.size();
}
inline void OfflineMessagePullRes::clear_msg() {
  msg_.Clear();
}
inline ::im::tox::proto::OfflineMessage* OfflineMessagePullRes::mutable_msg(int index) {
  // @@protoc_insertion_point(field_mutable:im.tox.proto.OfflineMessagePullRes.msg)
  return msg_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::im::tox::proto::OfflineMessage >*
OfflineMessagePullRes::mutable_msg() {
  // @@protoc_insertion_point(field_mutable_list:im.tox.proto.OfflineMessagePullRes.msg)
  return &msg_;
}
inline const ::im::tox::proto::OfflineMessage& OfflineMessagePullRes::msg(int index) const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessagePullRes.msg)
  return msg_.Get(index);
}
inline ::im::tox::proto::OfflineMessage* OfflineMessagePullRes::add_msg() {
  // @@protoc_insertion_point(field_add:im.tox.proto.OfflineMessagePullRes.msg)
  return msg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::im::tox::proto::OfflineMessage >&
OfflineMessagePullRes::msg() const {
  // @@protoc_insertion_point(field_list:im.tox.proto.OfflineMessagePullRes.msg)
  return msg_;
}

// uint32 left_count = 2;
inline void OfflineMessagePullRes::clear_left_count() {
  left_count_ = 0u;
}
inline ::google::protobuf::uint32 OfflineMessagePullRes::left_count() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessagePullRes.left_count)
  return left_count_;
}
inline void OfflineMessagePullRes::set_left_count(::google::protobuf::uint32 value) {
  
  left_count_ = value;
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessagePullRes.left_count)
}

// -------------------------------------------------------------------

// OfflineMessageDelReq

// uint64 last_msg_id = 2;
inline void OfflineMessageDelReq::clear_last_msg_id() {
  last_msg_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OfflineMessageDelReq::last_msg_id() const {
  // @@protoc_insertion_point(field_get:im.tox.proto.OfflineMessageDelReq.last_msg_id)
  return last_msg_id_;
}
inline void OfflineMessageDelReq::set_last_msg_id(::google::protobuf::uint64 value) {
  
  last_msg_id_ = value;
  // @@protoc_insertion_point(field_set:im.tox.proto.OfflineMessageDelReq.last_msg_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tox
}  // namespace im

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_message_2eproto
